// Generated by CoffeeScript 1.7.1
(function() {
  var BULLET, BUTTON, CONTEXT, FREE_LINE, INDENT, INDEX, NODE_LINE_1, NODE_LINE_COMMENT, PATH_SEP, PathFragment, STRING, XikiPath, XikiRequest, getIndent, match_tree_line, parseXikiPath, parseXikiRequest, parseXikiRequestFromTree,
    __slice = [].slice;

  XikiRequest = (function() {
    function XikiRequest(opts) {
      this.body = opts.body, this.nodePaths = opts.nodePaths, this.input = opts.input, this.action = opts.action, this.req = opts.req, this.res = opts.res;
      this.before = opts.before, this.after = opts.after, this.prefix = opts.prefix;
    }

    XikiRequest.prototype.getContext = function(context, xikiPath) {
      var ContextClass, ctx, _i, _j, _len, _len1, _ref, _ref1;
      if (!xikiPath) {
        _ref = this.nodePaths;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          xikiPath = _ref[_i];
          context = this.getContext(context, xikiPath);
        }
        return context;
      } else {
        _ref1 = context.contexts();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          ContextClass = _ref1[_j];
          ctx = new ContextClass();
          if (ctx.does(this, xikiPath)) {
            return ctx.getContext();
          }
        }
      }
    };

    XikiRequest.prototype.process = function(context) {
      var ctx;
      ctx = this.getContext(context);
      ctx[this.action](this);
      return ctx;
    };

    return XikiRequest;

  })();

  XikiPath = (function() {
    function XikiPath(nodePath) {
      this.nodePath = nodePath;
    }

    XikiPath.prototype.first = function() {
      return this.nodePath[0].name;
    };

    XikiPath.prototype.slice = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return new XikiPath((_ref = this.nodePath).slice.apply(_ref, args));
    };

    XikiPath.prototype.unshift = function(thing) {
      if (thing instanceof Array) {
        return this.nodePath.unshift((function(func, args, ctor) {
          ctor.prototype = func.prototype;
          var child = new ctor, result = func.apply(child, args);
          return Object(result) === result ? result : child;
        })(PathFragment, thing, function(){}));
      } else if (typeof thing === "string") {
        return this.nodePath.unshift(new PathFragment(thing));
      } else if (thing instanceof PathFragment) {
        return this.nodePath.unshift(thing);
      } else {
        throw "cannot unshift thing: " + thing;
      }
    };

    XikiPath.prototype.shift = function() {
      return this.slice(1);
    };

    XikiPath.prototype.empty = function() {
      return this.nodePath.length === 0;
    };

    return XikiPath;

  })();

  STRING = /(\\.|[^"\\]+)*/;

  INDEX = /\[(\d+)\](?=\/|$)/;

  BULLET = /[\-–—+]\s/;

  CONTEXT = /[@$]/;

  NODE_LINE_1 = /(\s*)@\s*(.*)/;

  INDENT = /^[ \t]*/;

  FREE_LINE = /(\s*)([^\-–—+].*)/;

  NODE_LINE_COMMENT = /^(.*)\s+(?:--|—|–|\#)\s+.*$/;

  PATH_SEP = /(?:\/| -> | → )/;

  BUTTON = /^(\s*)\[(\w+)\](?:\s+\[\w+\])*\s*$/;

  getIndent = require("./util").getIndent;

  match_tree_line = function(s) {
    var m, r;
    r = {};
    if (m = NODE_LINE_1.exec(s)) {
      return {
        indent: m[1],
        ctx: "@",
        node: [m[2]]
      };
    }
    r = {
      indent: getIndent(s),
      ctx: null
    };
    if (m = NODE_LINE_COMMENT.exec(s)) {
      s = m[1];
    }
    s = s.replace(/^\s+/, '').replace(/\s+$/, '');
    if (BULLET.test(s)) {
      s = s.slice(1).replace(/^\s+/, '');
    } else if (!CONTEXT.test(s[0])) {
      if (!r.indent) {
        r.node = [s];
        return r;
      }
      return null;
    }
    if (s[0] === "@") {
      s = s.slice(1).replace(/^\s+/, '');
      r.ctx = "@";
    } else if (s.slice(0, 2) === "$ ") {
      r.ctx = "$";
    } else if (s.slice(0, 2) === "``" && s.slice(-2) === "``") {
      s = s.slice(2, -2);
      r.ctx = '``';
    } else if (s[0] === "`" && s.slice(-1) === "`") {
      s = s.slice(1, -1);
      r.ctx = '`';
    } else if (s[0] === "`" && s.slice(-2) === "`_") {
      s = s.slice(1, -2);
      r.ctx = '`';
    }
    if (s[0] !== "$") {
      if (s.slice(-1) === "/") {
        s = s.slice(0, -1);
        r.node = s.split(PATH_SEP);
      } else {
        r.node = s.split(PATH_SEP);
      }
    } else {
      r.node = [s];
    }
    return r;
  };

  parseXikiPath = function(path) {
    var i, nodePath, nodePaths, np, p, _i, _len;
    np = path.split(/\//);
    nodePath = [];
    nodePaths = [nodePath];
    for (i = _i = 0, _len = np.length; _i < _len; i = ++_i) {
      p = np[i];
      if (p.slice(0, 2) === "$ ") {
        nodePaths.push([new PathFragment(np.slice(i).join("/"))]);
        break;
      }
      if (p[0] === "@") {
        nodePath = [new PathFragment(p.slice(1))];
        nodePaths.push(nodePath);
        continue;
      }
      nodePath.push(new PathFragment(p));
    }
    return nodePaths;
  };

  PathFragment = (function() {
    function PathFragment(name, position) {
      this.name = name;
      this.position = position != null ? position : 0;
    }

    PathFragment.prototype.toString = function() {
      if (this.position > 0) {
        return "" + this.name + "[" + this.position + "]";
      } else {
        return this.name;
      }
    };

    return PathFragment;

  })();

  parseXikiRequest = function(request) {
    var action, body, input, nodePaths, path, req, res;
    path = request.path, body = request.body, action = request.action, req = request.req, res = request.res;
    input = body || null;
    action = action || "open";
    if (request.path === "") {
      nodePaths = [new PathFragment("")];
      return new XikiRequest({
        body: body,
        nodePaths: nodePaths,
        input: input,
        action: action,
        req: req,
        res: res
      });
    } else {
      if (!request.path) {
        return parseXikiPathFromTree(request);
      } else {
        nodePaths = parseXikiPath(path);
        return new XikiRequest({
          body: body,
          nodePaths: nodePaths,
          input: input,
          action: action,
          req: req,
          res: res
        });
      }
    }
  };

  parseXikiRequestFromTree = function(_arg) {
    var action, body, collect_lines, i, indent, input, last_node_path, line, line_stripped, lines, m, mob, n, nodePaths, node_path, node_paths, nodes, np, old_line, p, path, process_line, req, res, s, _i, _indent, _j, _k, _len, _len1, _len2, _ref, _ref1;
    path = _arg.path, body = _arg.body, action = _arg.action, req = _arg.req, res = _arg.res;
    if (!action) {
      action = null;
    }
    lines = body.split(/\n/);
    node_path = [];
    node_paths = [node_path];
    old_line = null;
    indent = null;
    lines = body.replace(/\s+$/, '') + "\n";
    collect_lines = false;
    input = null;
    _ref = lines.split(/\n/).reverse().concat([null]);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      line = _ref[_i];
      process_line = null;
      if (line == null) {
        process_line = old_line;
      } else if (/\\\n$/.test(line)) {
        line = line.slice(0, -2) + old_line.replace(/^\s+/, '');
      } else {
        process_line = old_line;
      }
      old_line = line;
      if (process_line == null) {
        continue;
      }
      line = process_line;
      line_stripped = line.replace(/^\s+/, '').replace(/\s$/, '');
      if (collect_lines) {
        if (!line_stripped) {
          input.append(indent + "\n");
          continue;
        }
        if (line.slice(0, indent.length) === indent) {
          input.append(line);
          continue;
        }
        input = unindent(input.join(''));
        collect_lines = false;
        indent = null;
      }
      if (indent == null) {
        if (m = BUTTON.exec(line)) {
          input = [];
          _ref1 = [m[1], m[2]], indent = _ref1[0], action = _ref1[1];
          collect_lines = true;
          continue;
        }
      }
      mob = match_tree_line(line);
      if (!mob) {
        if (indent === null) {
          m = INDENT.exec(line);
          indent = m[0];
          node_path.push(new PathFragment(line_stripped));
          node_path = [];
          node_paths.push(node_path);
        }
        continue;
      }
      if (!line_stripped) {
        continue;
      }
      _indent = mob.indent;
      s = mob.node[0];
      nodes = mob.node.slice(1);
      for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
        n = nodes[_j];
        node_path.push(new PathFragment(n));
      }
      if (indent === null) {
        indent = _indent;
        if (!s) {
          break;
        }
        node_path.push(new PathFragment(s));
        if (mob.ctx) {
          node_path = [];
          node_paths.append(node_path);
        }
        continue;
      }
      if (_indent.length === 0) {
        node_path.push(new PathFragment(s));
        break;
      }
      if (_indent.length === indent.length) {
        if (node_path.length) {
          last_node_path = node_path[node_path.length - 1];
          if (last_node_path.name === s) {
            last_node_path.position += 1;
            continue;
          }
        }
      }
      if (0 < _indent.length && _indent.length < indent.length) {
        node_path.push(new PathFragment(s));
        if (mob.ctx) {
          node_path = [];
          node_paths.push(node_path);
        }
        indent = _indent;
      }
    }
    if (!node_path.length) {
      node_paths = node_paths.slice(0, -1);
    }
    for (i = _k = 0, _len2 = node_paths.length; _k < _len2; i = ++_k) {
      np = node_paths[i];
      node_paths[i] = np.reverse();
    }
    node_paths.reverse();
    nodePaths = (function() {
      var _l, _len3, _results;
      _results = [];
      for (_l = 0, _len3 = node_paths.length; _l < _len3; _l++) {
        p = node_paths[_l];
        _results.push(new XikiPath(p));
      }
      return _results;
    })();
    return new XikiRequest({
      body: body,
      nodePaths: nodePaths,
      input: input,
      action: action,
      req: req,
      res: res
    });
  };

  module.exports = {
    match_tree_line: match_tree_line,
    parseXikiRequest: parseXikiRequest,
    parseXikiPath: parseXikiPath,
    parseXikiRequestFromTree: parseXikiRequestFromTree
  };

}).call(this);
